"""LLVM IR Writer for VM Virtualization.

Generates modified IR with stub functions that call the VM interpreter,
and outputs bytecode as a C header file.
"""

from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Optional

from .ir_parser import IRFunction, IRModule
from .bytecode_gen import bytecode_to_c_array, bytecode_to_llvm_constant
from .utils import get_logger

logger = get_logger(__name__)


# =============================================================================
# Stub Function Generation
# =============================================================================

def generate_stub_function(
    func: IRFunction,
    bytecode: bytes,
    bytecode_global_name: str,
) -> str:
    """Generate LLVM IR stub function that calls vm_execute.

    The stub:
    1. Allocates an array for arguments (sext to i64)
    2. Gets pointer to bytecode constant
    3. Calls vm_execute(bytecode_ptr, args_ptr, arg_count)
    4. Truncates result to return type

    Args:
        func: Original function
        bytecode: Bytecode for this function
        bytecode_global_name: Name of the bytecode global constant

    Returns:
        LLVM IR string for the stub function
    """
    lines = []
    arg_count = len(func.arguments)
    bytecode_len = len(bytecode)

    # Generate function signature
    args_str = ", ".join(
        f"{arg.value_type} {arg.name}" for arg in func.arguments
    )
    lines.append(f"; Virtualized function - calls VM interpreter")
    lines.append(f"define {func.return_type} @{func.name}({args_str}) {{")
    lines.append("entry:")

    if arg_count > 0:
        # Allocate array for arguments: [N x i64]
        lines.append(f"  %args = alloca [{arg_count} x i64], align 8")

        # Store each argument (sign-extend to i64)
        for i, arg in enumerate(func.arguments):
            ptr_name = f"%arg{i}_ptr"
            ext_name = f"%arg{i}_ext"

            # Get pointer to array element
            lines.append(
                f"  {ptr_name} = getelementptr inbounds [{arg_count} x i64], "
                f"[{arg_count} x i64]* %args, i64 0, i64 {i}"
            )

            # Sign-extend argument to i64 (if not already i64)
            if arg.value_type == "i64":
                lines.append(f"  store i64 {arg.name}, i64* {ptr_name}, align 8")
            else:
                lines.append(f"  {ext_name} = sext {arg.value_type} {arg.name} to i64")
                lines.append(f"  store i64 {ext_name}, i64* {ptr_name}, align 8")

        # Cast args array to i64*
        lines.append(
            f"  %args_ptr = bitcast [{arg_count} x i64]* %args to i64*"
        )
    else:
        # No arguments - pass null
        lines.append("  %args_ptr = bitcast i64* null to i64*")

    # Get pointer to bytecode constant
    lines.append(
        f"  %bc_ptr = getelementptr inbounds [{bytecode_len} x i8], "
        f"[{bytecode_len} x i8]* @{bytecode_global_name}, i64 0, i64 0"
    )

    # Call vm_execute
    lines.append(
        f"  %vm_result = call i64 @vm_execute(i8* %bc_ptr, i32 {bytecode_len}, "
        f"i64* %args_ptr, i32 {arg_count})"
    )

    # Truncate result if needed
    if func.return_type == "i64":
        lines.append("  ret i64 %vm_result")
    elif func.return_type == "void":
        lines.append("  ret void")
    else:
        lines.append(f"  %result = trunc i64 %vm_result to {func.return_type}")
        lines.append(f"  ret {func.return_type} %result")

    lines.append("}")

    return "\n".join(lines)


def generate_vm_declare() -> str:
    """Generate the vm_execute function declaration."""
    return (
        "; VM interpreter declaration\n"
        "declare i64 @vm_execute(i8* nocapture readonly, i32, i64* nocapture readonly, i32)\n"
    )


# =============================================================================
# Module Writing
# =============================================================================

def write_virtualized_module(
    module: IRModule,
    bytecode_map: Dict[str, bytes],
    output_ll: Path,
    output_bytecode: Optional[Path] = None,
) -> None:
    """Write the virtualized module to output files.

    Args:
        module: Parsed IR module
        bytecode_map: Map of function name -> bytecode
        output_ll: Path to output .ll file
        output_bytecode: Optional path to output bytecode header
    """
    lines = []

    # Add header comment
    lines.append("; ModuleID = 'virtualized'")
    lines.append("; Generated by OAAS VM Virtualizer")
    lines.append("")

    # Add VM declaration
    lines.append(generate_vm_declare())
    lines.append("")

    # Add bytecode constants for virtualized functions
    for func_name, bytecode in bytecode_map.items():
        bc_global_name = f"bytecode_{sanitize_name(func_name)}"
        lines.append(bytecode_to_llvm_constant(bytecode, bc_global_name))
    lines.append("")

    # Add global lines from original module
    for line in module.global_lines:
        # Skip source_filename and target lines if we're adding our own
        if line.strip().startswith("source_filename"):
            continue
        if line.strip().startswith("; ModuleID"):
            continue
        lines.append(line)

    # Add functions
    for func_name, func in module.functions.items():
        # Add any between-function content
        if func_name in module.between_lines:
            for line in module.between_lines.get(func_name, []):
                lines.append(line)

        if func_name in bytecode_map:
            # Virtualized function - add stub
            bytecode = bytecode_map[func_name]
            bc_global_name = f"bytecode_{sanitize_name(func_name)}"
            stub = generate_stub_function(func, bytecode, bc_global_name)
            lines.append("")
            lines.append(stub)
        else:
            # Keep original function
            lines.append("")
            for line in func.raw_lines:
                lines.append(line)

    # Write output .ll file
    output_ll.parent.mkdir(parents=True, exist_ok=True)
    with open(output_ll, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    logger.info(f"Wrote virtualized IR to {output_ll}")

    # Write bytecode header if requested
    if output_bytecode:
        write_bytecode_header(bytecode_map, output_bytecode)


def write_bytecode_header(
    bytecode_map: Dict[str, bytes],
    output_path: Path,
) -> None:
    """Write bytecode as a C header file.

    Args:
        bytecode_map: Map of function name -> bytecode
        output_path: Path to output header file
    """
    lines = []
    lines.append("/**")
    lines.append(" * Generated bytecode for virtualized functions")
    lines.append(" * Do not edit manually - generated by OAAS VM Virtualizer")
    lines.append(" */")
    lines.append("")
    lines.append("#ifndef VM_BYTECODE_H")
    lines.append("#define VM_BYTECODE_H")
    lines.append("")
    lines.append("#include <stdint.h>")
    lines.append("")

    for func_name, bytecode in bytecode_map.items():
        array_name = f"bytecode_{sanitize_name(func_name)}"
        lines.append(f"/* Function: {func_name} ({len(bytecode)} bytes) */")
        lines.append(bytecode_to_c_array(bytecode, array_name))
        lines.append(f"#define {array_name.upper()}_SIZE {len(bytecode)}")
        lines.append("")

    lines.append("#endif /* VM_BYTECODE_H */")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    logger.info(f"Wrote bytecode header to {output_path}")


def sanitize_name(name: str) -> str:
    """Sanitize a name for use as a C/LLVM identifier.

    Args:
        name: Original name

    Returns:
        Sanitized name
    """
    # Replace non-alphanumeric characters with underscore
    result = ""
    for char in name:
        if char.isalnum() or char == "_":
            result += char
        else:
            result += "_"

    # Ensure it doesn't start with a digit
    if result and result[0].isdigit():
        result = "_" + result

    return result


# =============================================================================
# Passthrough Mode
# =============================================================================

def write_passthrough(
    module: IRModule,
    output_ll: Path,
) -> None:
    """Write module unchanged (passthrough mode).

    Used when no functions are virtualized.

    Args:
        module: Parsed IR module
        output_ll: Path to output .ll file
    """
    lines = []

    # Add global lines
    for line in module.global_lines:
        lines.append(line)

    # Add functions with between-lines
    for func_name, func in module.functions.items():
        if func_name in module.between_lines:
            for line in module.between_lines.get(func_name, []):
                lines.append(line)
        for line in func.raw_lines:
            lines.append(line)

    # Write output
    output_ll.parent.mkdir(parents=True, exist_ok=True)
    with open(output_ll, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    logger.info(f"Wrote passthrough IR to {output_ll}")
